//
// Created by Daemyung Jang on 2021/09/01.
//

#include "Base/Window.h"

#include <stdexcept>
#include <spdlog/spdlog.h>
#include <SDL_syswm.h>
#include <iostream>

// timing
float deltaTime = 0.0f;
float lastFrame = 0.0f;

// cursor
bool firstMouse = true;
float yaw = -90.0f;
float pitch = 0.0f;
float WIDTH = 1280.0f;
float HEIGHT = 720.0f;
float lastX = WIDTH / 2.0;
float lastY = HEIGHT / 2.0;

Window::Window(const Descriptor &descriptor) {
    if (SDL_Init(SDL_INIT_VIDEO)) {
        spdlog::error("{}", SDL_GetError());
        throw std::runtime_error("Fail to create Window.");
    }

    window_ = SDL_CreateWindow(descriptor.title.c_str(),
                               SDL_WINDOWPOS_CENTERED,
                               SDL_WINDOWPOS_CENTERED,
                               descriptor.size.x,
                               descriptor.size.y,
                               SDL_WINDOW_ALLOW_HIGHDPI);
    if (!window_) {
        spdlog::error("{}", SDL_GetError());
        throw std::runtime_error("Fail to create Window.");
    }
}

Window::~Window() {
    if (window_) {
        SDL_DestroyWindow(window_);
        window_ = nullptr;
    }

    SDL_Quit();
}

void Window::run(glm::vec3 &cameraPos, glm::vec3 &cameraFront, glm::vec3 &cameraUp, 
				 const std::function<void()> &startup, const std::function<void()> &update,
                 const std::function<void()> &render, const std::function<void()> &shutdown) {
    SDL_Event event;
	int	xpos, ypos;
    startup();
    SDL_ShowWindow(window_);

    while (process_event(event)) {
		float currentFrame = SDL_GetTicks();
		deltaTime = currentFrame - lastFrame;
		lastFrame = currentFrame;
		float cameraSpeed = 0.01f * deltaTime;
		const Uint8 *state = SDL_GetKeyboardState(nullptr);
		if (state[SDL_SCANCODE_W]) {
			cameraPos += cameraFront * cameraSpeed;
		}
		if (state[SDL_SCANCODE_S]) {
			cameraPos -= cameraFront * cameraSpeed;
		}
		if (state[SDL_SCANCODE_A]) {
			cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
		}
		if (state[SDL_SCANCODE_D]) {
			cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
		}

		if (firstMouse) {
			SDL_WarpMouseInWindow(window_, WIDTH / 2, HEIGHT / 2);
			firstMouse = false;
		}
		Uint32 buttons;
		buttons = SDL_GetMouseState(&xpos, &ypos);
		std::cout << "xpos = " << event.motion.xrel << ", ypos = " << event.motion.yrel << std::endl;
		float xoffset = xpos - lastX;
		float yoffset = lastY - ypos;
		std::cout << "xoffset = " << xoffset << ", yoffset = " << yoffset << std::endl;
		lastX = xpos;
		lastY = ypos;

		float sensitivity = 0.1f;
		xoffset *= sensitivity;
		yoffset *= sensitivity;

		yaw += xoffset;
		pitch += yoffset;

		if (pitch > 89.0f)
			pitch = 89.0f;
		if (pitch < -89.0f)
			pitch = -89.0f;

		glm::vec3 front;
		front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
		front.y = sin(glm::radians(pitch));
		front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
		cameraFront = glm::normalize(front);

        update();
        render();
		SDL_WarpMouseInWindow(window_, WIDTH / 2, HEIGHT / 2);
    }

    SDL_HideWindow(window_);
    shutdown();
}

void Window::stop() {
    SDL_Event event{};
    event.window.windowID = SDL_GetWindowID(window_);
    event.window.event = SDL_WINDOWEVENT_CLOSE;
    SDL_PushEvent(&event);
}

std::string Window::title() const {
    return SDL_GetWindowTitle(window_);
}

void Window::title(const std::string &title) {
    SDL_SetWindowTitle(window_, title.c_str());
}

glm::ivec2 Window::size() const {
    glm::ivec2 size;
    SDL_GetWindowSize(window_, &size.x, &size.y);
    return size;
}

void Window::size(const glm::ivec2 &size) {
    SDL_SetWindowSize(window_, size.x, size.y);
}

//void motion(SDL_MouseMotionEvent *mme)
//{
//    static bool initializing = true;  // For the first time
//    static int warpMotionX = 0, warpMotionY = 0;  // accumulated warp motion
//    if (initializing)
//    {
//        if (mme->x == midWindowX && mme->y == midWindowY)
//            initializing = false;
//        else
//            SDL_WarpMouse(midWindowX, midWindowY);
//    }
//    else if (mme->xrel != -warpMotionX || mme->yrel != -warpMotionY)
//    {
//        /****** Mouse moved by mme->xrel and mme->yrel ******/
//        warpMotionX += mme->xrel;
//        warpMotionY += mme->yrel;
//        SDL_WarpMouse(midWindowX, midWindowY);
//    }
//    else    // if event motion was negative of accumulated previous moves,
//            // then it is generated by SDL_WarpMotion
//        warpMotionX = warpMotionY = 0;
//}

bool Window::process_event(SDL_Event &event) const {
//    SDL_Event event;
//	float cameraSpeed = 0.01f * deltaTime;

    while (SDL_PollEvent(&event)) {
        if (should_close_window(event)) {
            return false;
        }
//		if (event.type == SDL_MOUSEMOTION) {
//			motion(&event.motion);
//		}
//		if (event.type == SDL_KEYDOWN) {
//			switch (event.key.keysym.sym) {
//				case SDLK_w:
//					cameraPos += cameraFront * cameraSpeed;
//					break;
//
//				case SDLK_s:
//					cameraPos -= cameraFront * cameraSpeed;
//					break;
//
//				case SDLK_a:
//					cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
//					break;
//
//				case SDLK_d:
//					cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
//					break;
//				default:
//					break;
//			}
//		}
    }
    return true;
}

bool Window::should_close_window(const SDL_Event &event) const {
    return event.window.windowID == SDL_GetWindowID(window_) && event.window.event == SDL_WINDOWEVENT_CLOSE;
}

//int FilterEvents(const SDL_Event &event) {
//}
